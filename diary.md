# AHC011


## 2022-05-28

スコア計算式的に、完全な木を作るのは前提になるだろう。

まず思いついた方針

1. タイルの種類ごとに個数を数える
1. スライド操作は気にせず任意の配置で木にする
1. 元の盤面からのマッピングを作る
1. あとは普通のスライドパズルを解く

木にするのがどれくらい実現可能なものなのか次第かな。

閉路が出来たらダメだけど、木になっている=全タイルが連結になっているなら、閉路無く木になっているとは言って良さそう。

マッピング作ってスライドパズル解くのは普通にやればできるだろうけど、手数最小化をヒューリスティックで頑張る感じ。

マッピング作るときにはパリティ合わせないとゴールできないのに注意。

適当に焼きなますことでどれくらい大きな木にできるかをやってみる。

これC++のほうが良かったりしないかな…悩む

Nが5種類しかないからtemplateで定数化しちゃって高速化というのもできるし（Crystalでもマクロ使いこなせばできるのではあろうけど…）

ビームサーチするだろうからnth_element使いたいんよなあ

C++で書くことにした。

木を作っている様子がわかるビジュアライザ作ろう

> 適当に焼きなますことでどれくらい大きな木にできるかをやってみる

ちょっと実験的に書いたけど焼きなましでは難しそうな感がある。DFSしてみる


C++用のAWS Batch環境を作っていたら、既存のコンピューティング環境がc3系を使うようになっていたことに気付いたのでc5系を使うように更新した

ターゲット盤面、タイルの種類の個数のパターンごとに埋め込めたりする…？　さすがにパターン数多いか？
一応生成してどんな分布になっているか見てみよう

=> さすがに全然無理だった

適当な木を作って、それに辺を足してどこかを切ってという遷移で個数が合うまでやる、で焼いてみよう。これは良い感じの遷移になりそうな予感がする

=> 割とすぐ見つかってくれた。やった。


