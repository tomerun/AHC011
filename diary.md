# AHC011

## 2022-06-05

ビームサーチやると言いつつ違うことやってしまっていた。いい加減やる

やった。細かい調整はまだだけどとりあえず0.5%くらいは上がった
```
seed:0000 score=8484
seed:0001 score=8528
seed:0002 score=8594
seed:0003 score=8512
seed:0004 score=8490
seed:0005 score=8310
seed:0006 score=8338
seed:0007 score=8584
seed:0008 score=8416
seed:0009 score=8557
seed:0010 score=8356
```

時間調整難しいな、短めのビーム幅で繰り返しやるようにする？

調整してるけど「ビーム幅を減らすと実行時間が伸びる」という現象が起こっている。なんだろう

実は動かしてる途中で気付かないうちに木になってることがあったりしない？
最後だけ確かめとくか
=> 若干あるな…一応入れとこう


たくさんテスト回したら数千件に1回だけ出るバグが…。直せて良かった。

ターゲット盤面生成、もっとひとつの親から生成する個数を増やすとだいぶ上がった
```
seed:0000 score=8623
seed:0001 score=8790
seed:0002 score=8662
seed:0003 score=8738
seed:0004 score=8750
seed:0005 score=8287
seed:0006 score=8513
seed:0007 score=8535
seed:0008 score=8711
seed:0009 score=8777
seed:0010 score=8542
```


## 2022-06-04

ビームサーチやる

実装難しいな、
とりあえず4方向別々に書いて破滅してるのを、盤面回転させてまとめるのをやるか。
少なくとも2方向はまとめる

途中経過の解の長さを見て、既存のベスト解と比較して早めに枝刈りするようにした。実質の速度向上

```
seed:0000 score=8299
seed:0001 score=8294
seed:0002 score=8330
seed:0003 score=8210
seed:0004 score=8155
seed:0005 score=8079
seed:0006 score=7988
seed:0007 score=8125
seed:0008 score=8169
seed:0009 score=8052
seed:0010 score=8333
```

いやこれやってもビームサーチとは相容れなくて無意味な物になる事ではあるが、最終的な解の質と途中状態での質が相関してることを確認できた、
つまりビームサーチが効きそうであることを確認できて良かった

=> ローカルでは良くなっているように見えたけど1000件テストすると変わってなかった…まあいいや


初期状態でのターゲットとのマンハッタン距離の和が答えとかなり相関している。
ターゲット盤面生成するときにこの距離を評価に加えてやれないか

=> 1%ちょい良くなった。とくにNが大きいケースで改善幅が大きい。
この部分を高速化するほど結果も良くなる形に持って行けた。
…と思ったけど1秒->5秒にして実行しても0.5%しか変わらんかった…そっか

```
seed:0000 score=8507
seed:0001 score=8294
seed:0002 score=8408
seed:0003 score=8230
seed:0004 score=8290
seed:0005 score=8102
seed:0006 score=8061
seed:0007 score=8262
seed:0008 score=8203
seed:0009 score=8272
seed:0010 score=8125
```

マンハッタン距離は左側・上側にあるセルだけを見れば良いかと思ったら盤面全体を見た方が若干良かった。意外

うわ1件テスト環境でsegmentation faultした…簡単に再現しない。
決定的な動作にして10000件動かしてみる => やっぱり再現しない

ターゲット盤面構築のところに細々した高速化の余地があったので1.5倍速くらいにした。

3つ同時に集めるパターンも作ってみるか
=>やった。まあこれくらいは良くなるでしょうというくらいの結果。

```
seed:0000 score=8461
seed:0001 score=8528
seed:0002 score=8477
seed:0003 score=8402
seed:0004 score=8395
seed:0005 score=8079
seed:0006 score=8324
seed:0007 score=8496
seed:0008 score=8340
seed:0009 score=8442
seed:0010 score=8241
```


## 2022-06-03

今の解で時間1秒→10秒にしてみたらどれくらい変わるのか見てみる
=> 2%くらい増えた。思っていたより変わる

ターゲット盤面決めない探索したらどうなるのか、軽くビームサーチしてみる
…ビームサーチよりA＊の方が書きやすいか？　それでやる
=> 単純にやっても全然無理そう。やっぱりまずターゲット盤面を作る方針じゃないとどうにもならなさそう

> 次2つ分の位置関係すべてについて最短で持ってこれる動きを前計算する

これをやる。4方向分をどう実装するかが難しい

実装大変だったけどまあそれなりには良くなった。上位には全然足りんけど

```
seed:0000 score=8183
seed:0001 score=8163
seed:0002 score=8057
seed:0003 score=8025
seed:0004 score=8025
seed:0005 score=8125
seed:0006 score=7988
seed:0007 score=7979
seed:0008 score=8080
seed:0009 score=8137
seed:0010 score=8102
```

9000件テスト実行してOK。

> ターゲット盤面を結果を元に焼きなまし

これをやってみる。
その前にまず現状の生成方法でどれくらい多様性があるものなのかを調べてみる。
=> ちゃんとほぼ毎回異なる盤面になっていた。N=6だと1%くらいは重複してるけど

単純にやっても逆効果。



## 2022-05-30 ~ 2022-06-02

平日は実装する時間・気力が足りないのでアイディア出しの時間

* 1箇所ずつ合わせていくのではなく、次の2箇所を同時に合わせる方法も試して良い方を採用する
  * あるいは次2つ分の位置関係すべてについて最短で持ってこれる動きを前計算する
* 最後の3x3部分を合わせるのは全部のパターンの解答を列挙しておいて探索無しで答えを出す
  * 高速化にしかならないから後回し
* 最後の4x4部分を幅優先で探索…は厳しいだろうからヒューリスティックな探索で短い手数の解を見つける
  * => やってみたが、かなり厳しい。時間かかるし解が見つかるケースも別にそんなに縮んでない
* 左1列・上1行分を木の一部として矛盾がない形にだけして、残りを使ってターゲット盤面を作る
  * その強い制約のもとでターゲット盤面が作れるかわからないが、ハマると強そう
  * 左・上と言わず1周やっても良いかも
* 1列分ずつ合わせる遷移などでビームサーチ
* ターゲット盤面の選別
* ターゲット盤面を結果を元に焼きなまし


公開されてるビジュアライザの画像見ると、空きマスを端で終端させずに高得点取ってるケースがあるなあ、気になる。
N=6だと探索が効くんかなあ


## 2022-05-29

ルールベースで動かすのなら、各タイルの行き先を最初に完全に決めてしまうのは解を限定しすぎてる気がする。
毎回近い所から合う形状のタイルを探してくるのがよさそう。

そうするとパリティが合わない場合が出てきそうだけど、1/2で当たるんだろうからランダム性入れて何回か繰り返せばそのうち当たるでしょうということで。

動いた。単純な貪欲しかしてなくて改善点ありまくりだけど平均70万点近く出てそうで良い感じ。

```
seed:0001 score=6633
seed:0002 score=6953
seed:0003 score=6955
seed:0004 score=7255
seed:0005 score=7338
seed:0006 score=7070
seed:0007 score=7187
seed:0008 score=6811
seed:0009 score=7250
```

とりあえずすぐ思いつくような改善をいろいろ入れたら74万点くらいにまではなった

```
seed:0001 score=7332
seed:0002 score=7549
seed:0003 score=7551
seed:0004 score=7345
seed:0005 score=7824
seed:0006 score=7522
seed:0007 score=7314
seed:0008 score=7366
seed:0009 score=7420
seed:0010 score=7662
```

時間の使い方が同じアルゴリズムを繰り返してるだけだから、もうちょっとなんかやりたいが

今は残りサイズ3になったら全探索してるけど、サイズ4でできないか？

N大だと焼きなましでターゲット盤面探すところがボトルネックになってる
=> 焼きなましの初期温度下げたらだいぶ良くなった

時間の前半は乱択して、結果が一番良かったターゲット盤面に対してビームサーチとか？
=> ビームサーチじゃなくて、とりあえず結果が一番良かったターゲット盤面に対して乱択を繰り返すようにしたらけっこう上がった。

```
seed:0001 score=7901
seed:0002 score=7725
seed:0003 score=7778
seed:0004 score=7665
seed:0005 score=8032
seed:0006 score=7857
seed:0007 score=7803
seed:0008 score=7716
seed:0009 score=7785
seed:0010 score=7755
```


既存の解に対してその作り方の一部を変化させる近傍って意味あるんかなあ、ハーフマラソンの魔法使いXの戦いで使えたみたいな


1回提出しておくか
=> 1位 39,029,302 （2位は38,307,047）

自環境よりは1%弱高めに出た。
最終的にはまず40は超えるんやろうなあ


今回ちょっとレアケースでのバグ死が怖いので大量テストは早めにやっておこう


## 2022-05-28

スコア計算式的に、完全な木を作るのは前提になるだろう。

まず思いついた方針

1. タイルの種類ごとに個数を数える
1. スライド操作は気にせず任意の配置で木にする
1. 元の盤面からのマッピングを作る
1. あとは普通のスライドパズルを解く

木にするのがどれくらい実現可能なものなのか次第かな。

閉路が出来たらダメだけど、木になっている=全タイルが連結になっているなら、閉路無く木になっているとは言って良さそう。

マッピング作ってスライドパズル解くのは普通にやればできるだろうけど、手数最小化をヒューリスティックで頑張る感じ。

マッピング作るときにはパリティ合わせないとゴールできないのに注意。

適当に焼きなますことでどれくらい大きな木にできるかをやってみる。

これC++のほうが良かったりしないかな…悩む

Nが5種類しかないからtemplateで定数化しちゃって高速化というのもできるし（Crystalでもマクロ使いこなせばできるのではあろうけど…）

ビームサーチするだろうからnth_element使いたいんよなあ

C++で書くことにした。

木を作っている様子がわかるビジュアライザ作ろう
=> いや、後でやった焼きなましですぐに見つかることがわかったので作らなくていいか

> 適当に焼きなますことでどれくらい大きな木にできるかをやってみる

ちょっと実験的に書いたけど焼きなましでは難しそうな感がある。DFSしてみる
=> ちょっと書こうとしたけど実装難しそう、別方針を考える

C++用のAWS Batch環境を作っていたら、既存のコンピューティング環境がc3系を使うようになっていたことに気付いたのでc5系を使うように更新した

ターゲット盤面、タイルの種類の個数のパターンごとに埋め込めたりする…？　さすがにパターン数多いか？
一応生成してどんな分布になっているか見てみよう
=> さすがに全然無理だった

適当な木を作って、それに辺を足してどこかを切ってという遷移で個数が合うまでやる、で焼いてみよう。これは良い感じの遷移になりそうな予感がする
=> 割とすぐ見つかってくれた。やった。1000ケース回したけど大丈夫っぽい。

ふつうのスライドパズルに帰着できたけど、それ解くのもけっこう難しいな。
適当なビームサーチじゃ全然揃わない

ルールベースに1行ずつ揃える=>1行揃えるのを単位としてビームサーチ、
としてみようか

いっぱい書いてたら初日で1000行超えてしまった

